---
title: "ELViS Vignette"
author: "Jin-Young Lee,Ph.D. and Hyo Young Choi, Ph.D."
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{ELViS_Toy_Example}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```





# 1. Introduction

## 1.1 BaReSegCN for Finding Small CNVs Within Viral Genome

------------------------------------------------------------------------

# 2. Run Example

## 2.1 Environment Setup and Package Installation

```{r}

```

## 2.2 Loading Toy Examples

Load required libraries.

```{r setup}


# chk <- Sys.getenv("_R_CHECK_LIMIT_CORES_", "")
# 
# if (nzchar(chk) && chk == "TRUE") {
# # use 2 cores in CRAN/Travis/AppVeyor
    library(ELViS)
# } else {
#     library(devtools)
#     document()
#     load_all()
# }

library(dplyr)
library(glue)
library(stringr)
# library(RPlotRNAseq)
# library(SCISSOR)
library(data.table)
library(ggplot2)
library(Rsamtools)
# library(GenomicAlignments)
library(parallel)
# library(GenomicFeatures)
# library(GenomicRanges)
library(patchwork)
library(ComplexHeatmap)
theme_set(theme_bw())
```




Generate base-resolution read depth matrix from a list of bam files. Parallel package is used to read files swiftly.

```{r}
analysis_dir = "~/ELViS"
dir.create(analysis_dir,showWarnings = FALSE)

package_name = "ELViS"

# load toy example meta data
data(toy_example,package = package_name)

# get lust of bam file paths
ext_path = system.file("extdata",package = package_name)
bam_files = list.files(ext_path,full.names = TRUE,pattern = "bam$")
# bam_files = paste(ext_path,toy_example$filename,sep="/")


# the name of the reference viral sequence the reads were aligned to
target_virus_name = "gi|333031|lcl|HPV16REF.1|"


```

bam reading example

```{r}
# 
# 
# chk <- Sys.getenv("_R_CHECK_LIMIT_CORES_", "")
# 
# if (nzchar(chk) && chk == "TRUE") {
    # use 2 cores in CRAN/Travis/AppVeyor
    
# } else {
#     # use all cores in devtools::test()
#     N_cores <- min(10,parallel::detectCores())
# }


 os_name = Sys.info()["sysname"]
if( os_name == "Windows" ){
  N_cores <- 1L
}else{
  N_cores <- 2L
}

 # = 4L

tmpdir="./tmpdir"
dir.create(tmpdir,recursive = TRUE)

system.time({
mtrx_samtools_reticulate__example = 
  get_depth_matrix(
    bam_files = bam_files,target_virus_name = target_virus_name
    ,mode = "samtools_reticulate"
    ,N_cores = N_cores
    ,min_mapq = 30
    ,tmpdir=tmpdir
    ,condaenv = "env_samtools"
    ,conda = "auto"
    ,remove_tmpdir = TRUE
  )
})

unlink(tmpdir,recursive=TRUE)

```




```{r eval=FALSE, , eval=FALSE, include=FALSE}

# Actual depth matrix of 120 samples had been generated using the follpwing code

SKIP=1
if(!SKIP){

# 120 bams
# 5.5 sec
system.time({
mtrx_Rsamtools = 
  get_depth_matrix(
    bam_files = bam_files,target_virus_name = target_virus_name
    ,mode = "Rsamtools"
    ,N_cores = N_cores
    ,max_depth = 1e5
    ,min_mapq = 30
    ,tmpdir="tmpdir"
  )
})

  }


# 4.7 sec
system.time({
mtrx_samtools_reticulate = 
  get_depth_matrix(
    bam_files = bam_files,target_virus_name = target_virus_name
    ,mode = "samtools_reticulate"
    ,N_cores = N_cores
    ,min_mapq = 30
    ,tmpdir="tmpdir"
    ,condaenv = "env_samtools"
    ,conda = "auto"
  )
})



SKIP=1
if(!SKIP){

#2.3 sec
system.time({
mtrx_samtools = 
  get_depth_matrix(
    bam_files = bam_files,target_virus_name = target_virus_name
    ,mode = "samtools_custom"
    ,N_cores = N_cores
    ,min_mapq = 30
    ,tmpdir="tmpdir"
    ,modules="samtools/samtools_bcftools_1.20__bedtools_2.31.1"
  )
})
# base_resol_depth = mtrx_samtools
}

# use_data(mtrx_samtools_reticulate)

```





Filter out low coverage sample and save depth matrix as RDS file for later reuse

Determine sample filtering threshold using histogram and get filtered data matrix

```{r,fig.width=5,fig.height=3}
# loading precalculated depth matrix
data(mtrx_samtools_reticulate)

# threshold
th = 50
# histogram with adjustable thresholds for custom function
depth_hist(mtrx_samtools_reticulate,th=th,smry_fun=max)
depth_hist(mtrx_samtools_reticulate,th=th,smry_fun=quantile,prob=0.75)

# filtered matrix
base_resol_depth = filt_samples(mtrx_samtools_reticulate,th=th,smry_fun=max)
print(base_resol_depth[1:4,1:4])

# save data for later use
saveRDS(base_resol_depth,"~/base_resol_depth.rds")
```




## 2.3 Run Pipeline

```{r , echo=TRUE, eval=FALSE}
# N_cores = 10
# N_cores = min(4,detectCores())

# save_dir = glue("{analysis_dir}/save_dir_toy")

system.time({
  result = run_ELViS(
    X = base_resol_depth
    ,N_cores=N_cores
    ,reduced_output=TRUE
    )
 
})

# usethis::use_data(result,overwrite = TRUE)
# 
# 
ELViS_toy_run_result = result
use_data(ELViS_toy_run_result)

# 4min for 120 samples


```

## 2.4 Plotting Figures

```{r,fig.width=7,fig.height=5}
data(ELViS_toy_run_result)
result = ELViS_toy_run_result

figure_dir = glue("{analysis_dir}/figures")
dir.create(figure_dir)
# give the gff3 file for the virus of your interest
gff3_fn = system.file("extdata","HPV16REF_PaVE.gff",package = package_name)

# Plotting raw depth profile
gg_lst_x = 
  plot_pileUp_multisample(
    result = result,
    X_raw = base_resol_depth,
    plot_target = "x",
    gff3 = gff3_fn,
    baseline=1,
    exclude_genes = c("E6*","E1^E4","E8^E2"),
  )

# Save to pdf file, set SKIP = FALSE if you want to save as pdf
SKIP = TRUE
if(!SKIP){
  pdf(glue("{figure_dir}/Raw_Depth_CNV_call.pdf"),height=4,width=6)
  gg_lst_x
  dev.off()
}

print(gg_lst_x[[1]])
```
You can adjust baseline after examining depth profile plots.

```{r,fig.width=7,fig.height=5}
new_baseline = get_new_baseline(result,mode="longest")

# Plotting raw depth profile with new baseline
gg_lst_x = 
  plot_pileUp_multisample(
    result = result,
    X_raw = base_resol_depth,
    plot_target = "x",
    gff3 = gff3_fn,
    baseline=new_baseline,
    exclude_genes = c("E6*","E1^E4","E8^E2"),
  )
# Save to pdf file, set SKIP = FALSE if you want to save as pdf
SKIP = TRUE
if(!SKIP){
  # Save to pdf file
  pdf("figures/Raw_Depth_new_baseline_CNV_call.pdf",height=4,width=6)
  gg_lst_x
  dev.off()
}
gg_lst_x[[1]]

```


```{r,fig.width=7,fig.height=5}
# Plotting normalized depth profile
gg_lst_y = 
  plot_pileUp_multisample(
    result = result,
    X_raw = base_resol_depth,
    plot_target = "y",
    gff3 = gff3_fn,
    baseline=new_baseline,
    exclude_genes = c("E6*","E1^E4","E8^E2"),
  )

# Save to pdf file
SKIP = TRUE
if(!SKIP){
  pdf("figures/Normalized_Depth_CNV_call.pdf",height=4,width=6)
  gg_lst_y
  dev.off()
}
gg_lst_y[[1]]
```


```{r,fig.width=7,fig.height=5}
# Plotting robust Z-score profile

gg_lst_z = 
  plot_pileUp_multisample(
    result = result,
    X_raw = base_resol_depth,
    plot_target = "z",
    gff3 = gff3_fn,
    baseline=new_baseline,
    exclude_genes = c("E6*","E1^E4","E8^E2")
  )

SKIP = TRUE
if(!SKIP){
# Save to pdf file
pdf("figures/Robust-Z-score_CNV_call.pdf",height=4,width=6)
gg_lst_z
dev.off()
}
gg_lst_z[[1]]

```

Generating heatmaps with integrative clustering.


Calculation of viral loads.
 - Get total aligned base using tools such as picard. Here we use randomly generated numbers instead.
 
```{r eval=FALSE, include=FALSE,echo = FALSE}
set.seed(54374373); total_aligned_base__host_and_virus = 
  c(
    sample( (4:6)*(10^8),80,replace = TRUE),
    sample( (7:10)*(10^8),20,replace = TRUE),
    sample( (1:3)*(10^8),20,replace = TRUE)
  )

use_data(total_aligned_base__host_and_virus,overwrite = TRUE)
```
 
 
```{r,fig.width=5,fig.height=4}
data(total_aligned_base__host_and_virus)


viral_load = (10^6)*(apply(base_resol_depth,2,\(x) sum(x)) )/total_aligned_base__host_and_virus

# distribtuion of overall viral load
viral_load %>%log10 %>% hist
```





```{r}
# col_z = circlize::colorRamp2(c(-10,0,10),c(muted("blue"),"white",muted("red")))
# col_pal_gene = piratepal(palette = "info2")

exclude_genes = c("E6*","E1^E4","E8^E2")
integ_ht_result = integrative_heatmap(
  X_raw = base_resol_depth,
  result = result,
  gff3_fn = gff3_fn,
  exclude_genes = exclude_genes,
  # baseline = new_baseline,
  baseline=1,
  # col_z = col_z,
  total_aligned_base__host_and_virus = total_aligned_base__host_and_virus
)

top_ant =
  HeatmapAnnotation(
    `Log2 Overall\nViral Load` = anno_points(log2(viral_load)),
    annotation_name_side = "left",annotation_name_rot=0)
```


maximum number of intact copies
 - min copy of the overlappint copy segments
 - ratio according to certain gene

```{r}
gene_ref="E7"

gene_cn = 
  gene_cn_heatmaps(
  X_raw = base_resol_depth,
  result = result,
  gff3_fn = gff3_fn,
  baseline = new_baseline,
  # baseline = 1,
  gene_ref = gene_ref,
  exclude_genes = exclude_genes
)




```


```{r,fig.width=7,fig.height=8}
draw(top_ant %v% integ_ht_result$Heatmap %v% gene_cn$Heatmaps$intact_gene_cn %v% gene_cn$Heatmaps$rel_dosage)
# minCN_mtrx %>%
#   dplyr::select(contains("6258"))

# integ_ht_result$Heatmap[,1:3]
```


------------------------------------------------------------------------

# 3. Parameter Setting

## 3.1 Available parameters

ddd

ddddddddddddddd

dddddddddddd

dddddddddddddd

dddddddddddd

d

-   b

-   c

b

c



# 4. sessionInfo

```{r}
sessionInfo()
```




## R Markdown

This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>.

When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:

```{r cars}
summary(cars)
```

## Including Plots

You can also embed plots, for example:

```{r pressure, echo=FALSE}
plot(pressure)
```

Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.
